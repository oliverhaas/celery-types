from typing import Any

STRTOBOOL_DEFAULT_TABLE: dict[str, bool]

class UnpickleableExceptionWrapper(Exception):
    exc_module: str
    exc_name: str
    exc_args: tuple[Any, ...]

    def __init__(
        self,
        exc_module: str,
        exc_name: str,
        exc_args: tuple[Any, ...],
        text: str = "",
    ) -> None: ...
    def restore(self) -> Exception: ...

def b64encode(s: bytes) -> bytes: ...
def b64decode(s: bytes) -> bytes: ...
def base64encode(s: bytes) -> bytes: ...
def base64decode(s: bytes) -> bytes: ...
def bytes_to_str(s: bytes | str) -> str: ...
def str_to_bytes(s: str | bytes) -> bytes: ...
def strtobool(term: str | bool | int | None, table: dict[str, bool] | None = None) -> bool: ...
def get_pickleable_exception(exc: Exception) -> Exception: ...
def get_pickleable_etype(cls: type[Exception], loads: Any = ..., dumps: Any = ...) -> type[Exception]: ...
def get_pickled_exception(exc: Exception) -> Exception: ...
def jsonify(obj: Any, builtin_types: tuple[type, ...] = ..., key: Any = None, keyfilter: Any = None) -> Any: ...
def raise_with_context(exc: Exception) -> None: ...
def find_pickleable_exception(
    exc: Exception,
    loads: Any = ...,
    dumps: Any = ...,
) -> Exception | None: ...
def ensure_serializable(objects: list[Any], encoder: Any) -> list[Any]: ...
def create_exception_cls(name: str, module: str, parent: type | None = None) -> type[Exception]: ...
def subclass_exception(name: str, parent: type[Exception], module: str | None = None) -> type[Exception]: ...
def itermro(cls: type, stop: type) -> Any: ...
def safe_repr(o: Any, max_length: int = 200) -> str: ...
